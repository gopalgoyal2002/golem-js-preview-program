import { DemandFactory } from "./factory.js";
import { Proposal } from "./proposal.js";
import { sleep } from "../utils/index.js";
import { Events } from "../events/index.js";
export const DemandEventType = "ProposalReceived";
export class Demand extends EventTarget {
    id;
    demandRequest;
    options;
    isRunning = true;
    logger;
    static async create(taskPackage, allocations, options) {
        const factory = new DemandFactory(taskPackage, allocations, options);
        return factory.create();
    }
    constructor(id, demandRequest, options) {
        super();
        this.id = id;
        this.demandRequest = demandRequest;
        this.options = options;
        this.logger = this.options.logger;
        this.subscribe().catch((e) => this.logger?.error(e));
    }
    async unsubscribe() {
        this.isRunning = false;
        await this.options.api.unsubscribeDemand(this.id);
        this.removeEventListener(DemandEventType, null);
        this.logger?.debug(`Demand ${this.id} unsubscribed`);
    }
    async subscribe() {
        while (this.isRunning) {
            try {
                const { data: events } = await this.options.api.collectOffers(this.id, 3, this.options.maxOfferEvents, {
                    timeout: 5000,
                });
                for (const event of events) {
                    if (event.eventType === "ProposalRejectedEvent") {
                        this.logger?.debug(`Proposal rejected. Reason: ${event.reason?.message}`);
                        continue;
                    }
                    else if (event.eventType !== "ProposalEvent")
                        continue;
                    const proposal = new Proposal(this.id, this.options.api, event.proposal, this.demandRequest, this.options.eventTarget);
                    this.dispatchEvent(new DemandEvent(DemandEventType, proposal));
                    this.options.eventTarget?.dispatchEvent(new Events.ProposalReceived({ id: proposal.id, providerId: proposal.issuerId }));
                }
            }
            catch (error) {
                if (this.isRunning) {
                    const reason = error.response?.data?.message || error;
                    this.options.eventTarget?.dispatchEvent(new Events.CollectFailed({ id: this.id, reason }));
                    this.logger?.warn(`Unable to collect offers. ${reason}`);
                }
            }
            finally {
                await sleep(this.options.offerFetchingInterval, true);
            }
        }
    }
}
export class DemandEvent extends Event {
    proposal;
    constructor(type, data) {
        super(type, data);
        this.proposal = data;
    }
}
//# sourceMappingURL=demand.js.map