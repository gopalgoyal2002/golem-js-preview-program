export const SCORE_NEUTRAL = 0.0;
export const SCORE_REJECTED = -1.0;
export const SCORE_TRUSTED = 100.0;
var Counter;
(function (Counter) {
    Counter["TIME"] = "golem.usage.duration_sec";
    Counter["CPU"] = "golem.usage.cpu_sec";
    Counter["STORAGE"] = "golem.usage.storage_gib";
    Counter["MAXMEM"] = "golem.usage.gib";
    Counter["UNKNOWN"] = "";
})(Counter || (Counter = {}));
export class DefaultMarketStrategy {
    defaultStrategy;
    constructor(computationHistory, logger) {
        this.defaultStrategy = new DecreaseScoreForUnconfirmedAgreementMarketStrategy(new LeastExpensiveLinearPayuMarketStrategy(60, 1.0, new Map([
            [Counter.TIME, 0.1],
            [Counter.CPU, 0.2],
        ]), logger), 0.5, computationHistory, logger);
    }
    getDemandDecoration() {
        return this.defaultStrategy.getDemandDecoration();
    }
    scoreProposal(proposal) {
        return this.defaultStrategy.scoreProposal(proposal);
    }
}
export class LeastExpensiveLinearPayuMarketStrategy {
    expectedTimeSecs;
    maxFixedPrice;
    maxPriceFor;
    logger;
    constructor(expectedTimeSecs = 60, maxFixedPrice, maxPriceFor, logger) {
        this.expectedTimeSecs = expectedTimeSecs;
        this.maxFixedPrice = maxFixedPrice;
        this.maxPriceFor = maxPriceFor;
        this.logger = logger;
    }
    getDemandDecoration() {
        return {
            constraints: [`(golem.com.pricing.model=linear)`],
            properties: [],
        };
    }
    scoreProposal(proposal) {
        if (proposal.properties["golem.com.scheme"] !== "payu") {
            this.logger?.debug(`Rejected offer ${proposal.id}: unsupported scheme '${proposal.properties["golem.com.scheme"]}'`);
            return SCORE_REJECTED;
        }
        const knownTimePrices = new Set([Counter.TIME, Counter.CPU]);
        const coeffs = proposal.properties["golem.com.pricing.model.linear.coeffs"] || [];
        const usages = proposal.properties["golem.com.usage.vector"] || [];
        const fixedPrice = parseFloat(coeffs.pop() || "0");
        let priceFor = {};
        for (let i = 0; i < coeffs.length; i++) {
            priceFor = { ...priceFor, [usages[i]]: parseFloat(coeffs[i]) };
        }
        for (const counter in priceFor) {
            if (!knownTimePrices.has(counter)) {
                this.logger?.debug(`Rejected offer ${proposal.id}: unsupported counter '${counter}'`);
                return SCORE_REJECTED;
            }
        }
        if (this.maxFixedPrice !== undefined) {
            if (fixedPrice > this.maxFixedPrice) {
                this.logger?.debug(`Rejected offer ${proposal.id}: fixed price higher than fixed price cap ${this.maxFixedPrice}.`);
                return SCORE_REJECTED;
            }
        }
        if (fixedPrice < 0) {
            this.logger?.debug(`Rejected offer ${proposal.id}: negative fixed price`);
            return SCORE_REJECTED;
        }
        let expectedPrice = fixedPrice;
        for (const resource of knownTimePrices) {
            if (priceFor[resource] < 0) {
                this.logger?.debug(`Rejected offer ${proposal.id}: negative price for '${resource}'`);
                return SCORE_REJECTED;
            }
            if (this.maxPriceFor) {
                const maxPrice = this.maxPriceFor.get(resource);
                if (maxPrice !== undefined && priceFor[resource] > maxPrice) {
                    this.logger?.debug(`Rejected offer ${proposal.id}: price for '${resource}' higher than price cap ${maxPrice}`);
                    return SCORE_REJECTED;
                }
            }
            expectedPrice += priceFor[resource] * this.expectedTimeSecs;
        }
        return SCORE_TRUSTED / (expectedPrice + 1.01);
    }
}
export class DecreaseScoreForUnconfirmedAgreementMarketStrategy {
    baseStrategy;
    factor;
    computationHistory;
    logger;
    constructor(baseStrategy, factor, computationHistory, logger) {
        this.baseStrategy = baseStrategy;
        this.factor = factor;
        this.computationHistory = computationHistory;
        this.logger = logger;
    }
    getDemandDecoration() {
        return this.baseStrategy.getDemandDecoration();
    }
    scoreProposal(proposal) {
        let score = this.baseStrategy.scoreProposal(proposal);
        if (this.computationHistory.isProviderLastAgreementRejected(proposal.issuerId) && score > 0) {
            score *= this.factor;
            this.logger?.debug(`Decreasing score for offer ${proposal.id} from '${proposal.issuerId}'`);
        }
        return score;
    }
}
//# sourceMappingURL=strategy.js.map