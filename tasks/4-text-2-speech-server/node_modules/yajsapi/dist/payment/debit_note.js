import { InvoiceConfig } from './config.js';
import { BaseNote } from './invoice.js';
import { Events } from '../events/index.js';
export class DebitNote extends BaseNote {
    options;
    id;
    previousDebitNoteId;
    timestamp;
    activityId;
    totalAmountDue;
    usageCounterVector;
    static async create(debitNoteId, options) {
        const config = new InvoiceConfig(options);
        const { data: model } = await config.api.getDebitNote(debitNoteId);
        return new DebitNote(model, config);
    }
    constructor(model, options) {
        super(model, options);
        this.options = options;
        this.id = model.debitNoteId;
        this.timestamp = model.timestamp;
        this.activityId = model.activityId;
        this.totalAmountDue = model.totalAmountDue;
        this.usageCounterVector = model.usageCounterVector;
    }
    async accept(totalAmountAccepted, allocationId) {
        try {
            await this.options.api.acceptDebitNote(this.id, { totalAmountAccepted, allocationId });
        }
        catch (e) {
            const reason = e?.response?.data?.message || e;
            this.options.eventTarget?.dispatchEvent(new Events.PaymentFailed({ id: this.id, agreementId: this.agreementId, reason }));
            throw new Error(`Unable to accept debit note ${this.id} ${e?.response?.data?.message || e}`);
        }
    }
    async reject(rejection) {
        try {
            await this.options.api.rejectDebitNote(this.id, rejection);
        }
        catch (e) {
            throw new Error(`Unable to reject debit note ${this.id} ${e?.response?.data?.message || e}`);
        }
        finally {
            this.options.eventTarget?.dispatchEvent(new Events.PaymentFailed({ id: this.id, agreementId: this.agreementId, reason: rejection.message }));
        }
    }
    async refreshStatus() {
        const { data: model } = await this.options.api.getDebitNote(this.id);
        this.status = model.status;
    }
}
//# sourceMappingURL=debit_note.js.map