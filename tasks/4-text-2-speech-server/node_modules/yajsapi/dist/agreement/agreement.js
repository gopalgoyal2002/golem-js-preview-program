import { AgreementFactory } from "./factory.js";
import { Events } from "../events/index.js";
export var AgreementStateEnum;
(function (AgreementStateEnum) {
    AgreementStateEnum["Proposal"] = "Proposal";
    AgreementStateEnum["Pending"] = "Pending";
    AgreementStateEnum["Cancelled"] = "Cancelled";
    AgreementStateEnum["Rejected"] = "Rejected";
    AgreementStateEnum["Approved"] = "Approved";
    AgreementStateEnum["Expired"] = "Expired";
    AgreementStateEnum["Terminated"] = "Terminated";
})(AgreementStateEnum || (AgreementStateEnum = {}));
export class Agreement {
    id;
    provider;
    options;
    agreementData;
    logger;
    constructor(id, provider, options) {
        this.id = id;
        this.provider = provider;
        this.options = options;
        this.logger = options.logger;
    }
    static async create(proposalId, agreementOptions) {
        const factory = new AgreementFactory(agreementOptions);
        return factory.create(proposalId);
    }
    async refreshDetails() {
        const { data } = await this.options.api.getAgreement(this.id, { timeout: this.options.agreementRequestTimeout });
        this.agreementData = data;
    }
    async getState() {
        await this.refreshDetails();
        return this.agreementData.state;
    }
    async confirm() {
        try {
            await this.options.api.confirmAgreement(this.id);
            await this.options.api.waitForApproval(this.id, this.options.agreementWaitingForApprovalTimeout);
            this.logger?.debug(`Agreement ${this.id} approved`);
            this.options.eventTarget?.dispatchEvent(new Events.AgreementConfirmed({ id: this.id, providerId: this.provider.id }));
        }
        catch (error) {
            this.logger?.error(`Unable to confirm agreement ${this.id}. ${error}`);
            throw error;
        }
    }
    async isFinalState() {
        const state = await this.getState();
        return state !== AgreementStateEnum.Pending && state !== AgreementStateEnum.Proposal;
    }
    async terminate(reason = { message: "Finished" }) {
        try {
            await this.options.api.terminateAgreement(this.id, reason);
            this.options.eventTarget?.dispatchEvent(new Events.AgreementTerminated({ id: this.id, providerId: this.provider.id }));
            this.logger?.debug(`Agreement ${this.id} terminated`);
        }
        catch (error) {
            throw new Error(`Unable to terminate agreement ${this.id}. ${error.response?.data?.message || error.response?.data || error}`);
        }
    }
}
//# sourceMappingURL=agreement.js.map