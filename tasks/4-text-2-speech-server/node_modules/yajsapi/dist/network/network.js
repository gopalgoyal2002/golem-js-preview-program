import { IPv4, IPv4Prefix, IPv4CidrRange } from "ip-num";
import { NetworkConfig } from "./config.js";
import { NetworkNode } from "./node.js";
export class NetworkError extends Error {
}
export class Network {
    id;
    config;
    ip;
    ipRange;
    ipIterator;
    mask;
    ownerId;
    ownerIp;
    gateway;
    nodes = new Map();
    logger;
    static async create(options) {
        const config = new NetworkConfig(options);
        try {
            const { data: { id, ip, mask }, } = await config.api.createNetwork({
                id: config.ownerId,
                ip: config.ip,
                mask: config.mask,
                gateway: config.gateway,
            });
            const network = new Network(id, config);
            await network.addNode(network.ownerId, network.ownerIp.toString()).catch(async (e) => {
                await config.api.removeNetwork(id);
                throw e;
            });
            config.logger?.info(`Network created: ID: ${id}, IP: ${ip}, Mask: ${mask}`);
            return network;
        }
        catch (error) {
            throw new Error(`Unable to create network. ${error?.response?.data?.message || error}`);
        }
    }
    constructor(id, config) {
        this.id = id;
        this.config = config;
        this.ipRange = IPv4CidrRange.fromCidr(config.mask ? `${config.ip}/${config.mask}` : config.ip);
        this.ipIterator = this.ipRange[Symbol.iterator]();
        this.ip = this.nextAddress();
        this.mask = this.ipRange.getPrefix().toMask();
        this.ownerId = config.ownerId;
        this.ownerIp = config.ownerIp ? new IPv4(config.ownerIp) : this.nextAddress();
        this.gateway = config.gateway ? new IPv4(config.gateway) : undefined;
        this.logger = config.logger;
    }
    getNetworkInfo() {
        return {
            id: this.id,
            ip: this.ip.toString(),
            mask: this.mask.toString(),
            nodes: Object.fromEntries(Array.from(this.nodes).map(([id, node]) => [node.ip.toString(), id])),
        };
    }
    async addNode(nodeId, ip) {
        this.ensureIdUnique(nodeId);
        let ipv4;
        if (ip) {
            ipv4 = IPv4.fromString(ip);
            this.ensureIpInNetwork(ipv4);
            this.ensureIpUnique(ipv4);
        }
        else {
            while (true) {
                ipv4 = this.nextAddress();
                if (this.isIpUnique(ipv4))
                    break;
            }
        }
        const node = new NetworkNode(nodeId, ipv4, this.getNetworkInfo.bind(this), this.getUrl());
        this.nodes.set(nodeId, node);
        await this.config.api.addNode(this.id, { id: nodeId, ip: ipv4.toString() });
        this.logger?.debug(`Node has added to the network. ID: ${nodeId}, IP: ${ipv4.toString()}`);
        return node;
    }
    async remove() {
        try {
            await this.config.api.removeNetwork(this.id);
        }
        catch (error) {
            if (error.status === 404)
                this.logger?.warn(`Tried removing a network which doesn't exist. Network ID: ${this.id}`);
            return false;
        }
        this.logger?.info(`Network has removed: ID: ${this.id}, IP: ${this.ip}`);
        return true;
    }
    nextAddress() {
        const ip = this.ipIterator.next().value;
        if (!ip)
            throw new Error(`No more addresses available in ${this.ipRange.toCidrString()}`);
        return ip;
    }
    ensureIpInNetwork(ip) {
        if (!this.ipRange.contains(new IPv4CidrRange(ip, new IPv4Prefix(BigInt(this.mask.prefix)))))
            throw new NetworkError(`The given IP ('${ip.toString()}') address must belong to the network ('${this.ipRange.toCidrString()}').`);
        return true;
    }
    ensureIpUnique(ip) {
        if (!this.isIpUnique(ip))
            throw new NetworkError(`IP '${ip.toString()}' has already been assigned in this network.`);
    }
    ensureIdUnique(id) {
        if (this.nodes.has(id))
            throw new NetworkError(`ID '${id}' has already been assigned in this network.`);
    }
    isIpUnique(ip) {
        for (const node of this.nodes.values()) {
            if (node.ip.isEquals(ip))
                return false;
        }
        return true;
    }
    getUrl() {
        return this.config.apiUrl;
    }
}
//# sourceMappingURL=network.js.map