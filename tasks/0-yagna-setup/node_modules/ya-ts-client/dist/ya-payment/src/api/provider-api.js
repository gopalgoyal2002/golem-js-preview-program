"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Yagna Payment API
 *  Invoicing and Payments is a fundamental area of Yagna Ecosystem functionality. It includes aspects of communication between Requestor, Provider and a selected Payment Platform, which becomes crucial when Activities are executed in the context of negotiated Agreements. Yagna applications must be able to exercise various payment models, and the Invoicing/Payment-related communication is happening in parallel to Activity control communication. To define functional patterns of Requestor/Provider interaction in this area, Payment API is specified.  An important principle of the Yagna Payment API is that the actual payment transactions are hidden behind the Invoice flow. In other words, a Yagna Application on Requestor side isn’t expected to trigger actual payment transactions. Instead it is expected to receive and accept Invoices raised by the Provider - based on Application’s Invoice Accept notifications, the Payment API implementation orchestrates the payment via a configured Payment platform.  **NOTE:** This specification is work-in-progress.
 *
 * The version of the OpenAPI document: 1.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderApi = exports.ProviderApiFactory = exports.ProviderApiFp = exports.ProviderApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../../common");
// @ts-ignore
const base_1 = require("../../base");
/**
 * ProviderApi - axios parameter creator
 * @export
 */
exports.ProviderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * **WARNING:** Operation not implemented.  This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already accepted it.
         * @summary Cancel Debit Note.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDebitNote: (debitNoteId, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            common_1.assertParamExists('cancelDebitNote', 'debitNoteId', debitNoteId);
            const localVarPath = `/debitNotes/{debitNoteId}/cancel`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already accepted it.
         * @summary Cancel Invoice.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice: (invoiceId, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('cancelInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/invoices/{invoiceId}/cancel`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote: (debitNoteId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            common_1.assertParamExists('getDebitNote', 'debitNoteId', debitNoteId);
            const localVarPath = `/debitNotes/{debitNoteId}`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/debitNoteEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes: (afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/debitNotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: (invoiceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('getInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoiceEvents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: (afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: (paymentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'paymentId' is not null or undefined
            common_1.assertParamExists('getPayment', 'paymentId', paymentId);
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: (timeout, afterTimestamp, maxEvents, appSessionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxEvents !== undefined) {
                localVarQueryParameter['maxEvents'] = maxEvents;
            }
            if (appSessionId !== undefined) {
                localVarQueryParameter['appSessionId'] = appSessionId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote: (debitNoteId, afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            common_1.assertParamExists('getPaymentsForDebitNote', 'debitNoteId', debitNoteId);
            const localVarPath = `/debitNotes/{debitNoteId}/payments`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForInvoice: (invoiceId, afterTimestamp, maxItems, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('getPaymentsForInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (afterTimestamp !== undefined) {
                localVarQueryParameter['afterTimestamp'] = (afterTimestamp instanceof Date) ?
                    afterTimestamp.toISOString() :
                    afterTimestamp;
            }
            if (maxItems !== undefined) {
                localVarQueryParameter['maxItems'] = maxItems;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get available accounts for receiving payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccounts: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/providerAccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Issue a Debit Note.
         * @param {DebitNote} debitNote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDebitNote: (debitNote, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNote' is not null or undefined
            common_1.assertParamExists('issueDebitNote', 'debitNote', debitNote);
            const localVarPath = `/debitNotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(debitNote, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice: (invoice, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoice' is not null or undefined
            common_1.assertParamExists('issueInvoice', 'invoice', invoice);
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(invoice, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed.
         * @summary Send Debit Note to Requestor.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDebitNote: (debitNoteId, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'debitNoteId' is not null or undefined
            common_1.assertParamExists('sendDebitNote', 'debitNoteId', debitNoteId);
            const localVarPath = `/debitNotes/{debitNoteId}/send`
                .replace(`{${"debitNoteId"}}`, encodeURIComponent(String(debitNoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed.
         * @summary Send Invoice to Requestor.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoice: (invoiceId, timeout, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invoiceId' is not null or undefined
            common_1.assertParamExists('sendInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/invoices/{invoiceId}/send`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication app_key required
            // http bearer authentication required
            yield common_1.setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProviderApi - functional programming interface
 * @export
 */
exports.ProviderApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ProviderApiAxiosParamCreator(configuration);
    return {
        /**
         * **WARNING:** Operation not implemented.  This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already accepted it.
         * @summary Cancel Debit Note.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDebitNote(debitNoteId, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelDebitNote(debitNoteId, timeout, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already accepted it.
         * @summary Cancel Invoice.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(invoiceId, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelInvoice(invoiceId, timeout, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote(debitNoteId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDebitNote(debitNoteId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes(afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDebitNotes(afterTimestamp, maxItems, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoice(invoiceId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoices(afterTimestamp, maxItems, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayment(paymentId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get available accounts for receiving payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccounts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProviderAccounts(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Issue a Debit Note.
         * @param {DebitNote} debitNote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDebitNote(debitNote, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.issueDebitNote(debitNote, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice(invoice, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.issueInvoice(invoice, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed.
         * @summary Send Debit Note to Requestor.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDebitNote(debitNoteId, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendDebitNote(debitNoteId, timeout, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed.
         * @summary Send Invoice to Requestor.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoice(invoiceId, timeout, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.sendInvoice(invoiceId, timeout, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
/**
 * ProviderApi - factory interface
 * @export
 */
exports.ProviderApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ProviderApiFp(configuration);
    return {
        /**
         * **WARNING:** Operation not implemented.  This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already accepted it.
         * @summary Cancel Debit Note.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDebitNote(debitNoteId, timeout, options) {
            return localVarFp.cancelDebitNote(debitNoteId, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already accepted it.
         * @summary Cancel Invoice.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(invoiceId, timeout, options) {
            return localVarFp.cancelInvoice(invoiceId, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Debit Note.
         * @param {string} debitNoteId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNote(debitNoteId, options) {
            return localVarFp.getDebitNote(debitNoteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Debit Note events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return localVarFp.getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebitNotes(afterTimestamp, maxItems, options) {
            return localVarFp.getDebitNotes(afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Invoice.
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, options) {
            return localVarFp.getInvoice(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
         * @summary Get Invoice events.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return localVarFp.getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(afterTimestamp, maxItems, options) {
            return localVarFp.getInvoices(afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Payment.
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, options) {
            return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
         * @summary Get Payments.
         * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxEvents] Maximum number of events that server should return at once.
         * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
            return localVarFp.getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Debit Note.
         * @param {string} debitNoteId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
            return localVarFp.getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         * **WARNING:** Operation not implemented.
         * @summary Get Payments for Invoice.
         * @param {string} invoiceId
         * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
         * @param {number} [maxItems] Maximum number of items that server should return at once.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
            return localVarFp.getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get available accounts for receiving payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderAccounts(options) {
            return localVarFp.getProviderAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Issue a Debit Note.
         * @param {DebitNote} debitNote
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDebitNote(debitNote, options) {
            return localVarFp.issueDebitNote(debitNote, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Issue an Invoice.
         * @param {Invoice} invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueInvoice(invoice, options) {
            return localVarFp.issueInvoice(invoice, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed.
         * @summary Send Debit Note to Requestor.
         * @param {string} debitNoteId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDebitNote(debitNoteId, timeout, options) {
            return localVarFp.sendDebitNote(debitNoteId, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed.
         * @summary Send Invoice to Requestor.
         * @param {string} invoiceId
         * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoice(invoiceId, timeout, options) {
            return localVarFp.sendInvoice(invoiceId, timeout, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProviderApi - object-oriented interface
 * @export
 * @class ProviderApi
 * @extends {BaseAPI}
 */
class ProviderApi extends base_1.BaseAPI {
    /**
     * **WARNING:** Operation not implemented.  This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Debit Note or timeout has passed. The Requestor may refuse to cancel the Debit Note if they have already accepted it.
     * @summary Cancel Debit Note.
     * @param {string} debitNoteId
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    cancelDebitNote(debitNoteId, timeout, options) {
        return exports.ProviderApiFp(this.configuration).cancelDebitNote(debitNoteId, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. It will not return until the Requestor has acknowledged cancelling the Invoice or timeout has passed. The Requestor may refuse to cancel the Invoice if they have already accepted it.
     * @summary Cancel Invoice.
     * @param {string} invoiceId
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    cancelInvoice(invoiceId, timeout, options) {
        return exports.ProviderApiFp(this.configuration).cancelInvoice(invoiceId, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Debit Note.
     * @param {string} debitNoteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getDebitNote(debitNoteId, options) {
        return exports.ProviderApiFp(this.configuration).getDebitNote(debitNoteId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Listen for Debit Note-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     * @summary Get Debit Note events.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.ProviderApiFp(this.configuration).getDebitNoteEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Debit Notes known by this node (either issued by this Provider or received by this Requestor).
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getDebitNotes(afterTimestamp, maxItems, options) {
        return exports.ProviderApiFp(this.configuration).getDebitNotes(afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Invoice.
     * @param {string} invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getInvoice(invoiceId, options) {
        return exports.ProviderApiFp(this.configuration).getInvoice(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Listen for Invoice-related events using long-polling. If there are any events the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' events. Setting the parameter value to the timestamp of the last processed event ensures that no events will go unnoticed.  **NOTE:** The events are persistent, ie. calling the API does not remove the event records from receiving queue.
     * @summary Get Invoice events.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.ProviderApiFp(this.configuration).getInvoiceEvents(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Invoices known to this node (either issued by this Provider or received by this Requestor).
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getInvoices(afterTimestamp, maxItems, options) {
        return exports.ProviderApiFp(this.configuration).getInvoices(afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Payment.
     * @param {string} paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getPayment(paymentId, options) {
        return exports.ProviderApiFp(this.configuration).getPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Payments can be treated as events and this method can be used to listen for new payments by long-polling.  If there are any payments the method will return them immediately. If there are none the method will wait until one appears or timeout passes. `afterTimestamp` parameter can be used in order to get just the \'new\' payments. Setting the parameter value to the timestamp of the last processed payment ensures that no payments will go unnoticed.
     * @summary Get Payments.
     * @param {number} [timeout] Timeout used in long-polling calls (in seconds). How many seconds server should wait for response containing new events (&#x60;0.0&#x60; means it should return immediately if there are no events)
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxEvents] Maximum number of events that server should return at once.
     * @param {string} [appSessionId] A correlation/session identifier used for querying events related to an action where this appSessionId has been specified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options) {
        return exports.ProviderApiFp(this.configuration).getPayments(timeout, afterTimestamp, maxEvents, appSessionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **WARNING:** Operation not implemented.
     * @summary Get Payments for Debit Note.
     * @param {string} debitNoteId
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options) {
        return exports.ProviderApiFp(this.configuration).getPaymentsForDebitNote(debitNoteId, afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * **WARNING:** Operation not implemented.
     * @summary Get Payments for Invoice.
     * @param {string} invoiceId
     * @param {string} [afterTimestamp] Apply only to records created later than the specified timestamp
     * @param {number} [maxItems] Maximum number of items that server should return at once.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options) {
        return exports.ProviderApiFp(this.configuration).getPaymentsForInvoice(invoiceId, afterTimestamp, maxItems, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get available accounts for receiving payments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    getProviderAccounts(options) {
        return exports.ProviderApiFp(this.configuration).getProviderAccounts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Issue a Debit Note.
     * @param {DebitNote} debitNote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    issueDebitNote(debitNote, options) {
        return exports.ProviderApiFp(this.configuration).issueDebitNote(debitNote, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Issue an Invoice.
     * @param {Invoice} invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    issueInvoice(invoice, options) {
        return exports.ProviderApiFp(this.configuration).issueInvoice(invoice, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Debit Note or timeout has passed.
     * @summary Send Debit Note to Requestor.
     * @param {string} debitNoteId
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    sendDebitNote(debitNoteId, timeout, options) {
        return exports.ProviderApiFp(this.configuration).sendDebitNote(debitNoteId, timeout, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is a blocking operation. It will not return until the Requestor has acknowledged receiving the Invoice or timeout has passed.
     * @summary Send Invoice to Requestor.
     * @param {string} invoiceId
     * @param {number} [timeout] Timeout used in blocking calls waiting for eg. acknowledgement. How many seconds server should wait for response/acknowledgement of an action (0.0 means it should wait for other party\&#39;s response indefinitely)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderApi
     */
    sendInvoice(invoiceId, timeout, options) {
        return exports.ProviderApiFp(this.configuration).sendInvoice(invoiceId, timeout, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProviderApi = ProviderApi;
