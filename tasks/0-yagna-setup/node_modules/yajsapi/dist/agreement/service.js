import { Agreement, AgreementStateEnum } from "./agreement.js";
import sleep from "../utils/sleep.js";
import { AgreementServiceConfig } from "./config.js";
export class AgreementPoolService {
    agreementServiceOptions;
    logger;
    config;
    proposals = [];
    agreements = new Map();
    agreementIdsToReuse = [];
    isServiceRunning = false;
    lastAgreementRejectedByProvider = new Map();
    initialTime = Date.now();
    constructor(agreementServiceOptions) {
        this.agreementServiceOptions = agreementServiceOptions;
        this.config = new AgreementServiceConfig(agreementServiceOptions);
        this.logger = agreementServiceOptions?.logger;
    }
    async run() {
        this.isServiceRunning = true;
        this.initialTime = +new Date();
        this.logger?.debug("Agreement Pool Service has started");
    }
    addProposal(proposalId) {
        this.proposals.push(proposalId);
        this.logger?.debug(`New offer proposal added to pool (${proposalId})`);
    }
    async getAgreement() {
        let agreement;
        while (!agreement && this.isServiceRunning)
            agreement = (await this.getAvailableAgreement()) || (await this.createAgreement());
        if (!agreement && !this.isServiceRunning)
            throw new Error("Unable to get agreement. Agreement service is not running");
        return agreement;
    }
    async releaseAgreement(agreementId, allowReuse = false) {
        const agreement = await this.agreements.get(agreementId);
        if (!agreement) {
            throw new Error(`Agreement ${agreementId} cannot found in pool`);
        }
        if (allowReuse) {
            this.agreementIdsToReuse.unshift(agreementId);
            this.logger?.debug(`Agreement ${agreementId} has been released for reuse`);
        }
        else {
            await agreement.terminate();
            this.agreements.delete(agreementId);
            this.logger?.debug(`Agreement ${agreementId} has been released and terminated`);
        }
    }
    async end() {
        this.isServiceRunning = false;
        await this.terminateAll({ message: "All computations done" });
        this.logger?.debug("Agreement Pool Service has been stopped");
    }
    isProviderLastAgreementRejected(providerId) {
        return !!this.lastAgreementRejectedByProvider.get(providerId);
    }
    async terminateAll(reason) {
        for (const agreement of this.agreements.values()) {
            if ((await agreement.getState()) !== AgreementStateEnum.Terminated)
                await agreement
                    .terminate(reason)
                    .catch((e) => this.logger?.warn(`Agreement ${agreement.id} cannot be terminated. ${e}`));
        }
    }
    async getAvailableAgreement() {
        let readyAgreement;
        while (!readyAgreement && this.agreementIdsToReuse.length > 0) {
            const availableAgreementId = this.agreementIdsToReuse.pop();
            if (!availableAgreementId)
                continue;
            const availableAgreement = this.agreements.get(availableAgreementId);
            if (!availableAgreement)
                throw new Error(`Agreement ${availableAgreementId} cannot found in pool`);
            const state = await availableAgreement.getState().catch((e) => {
                this.logger?.warn(`Unable to retrieve state of agreement ${availableAgreement.id}. ` + e);
            });
            if (state !== AgreementStateEnum.Approved) {
                this.logger?.debug(`Agreement ${availableAgreement.id} is no longer available. Current state: ${state}`);
                continue;
            }
            readyAgreement = availableAgreement;
        }
        return readyAgreement;
    }
    async createAgreement() {
        let agreement;
        while (!agreement && this.isServiceRunning) {
            const proposalId = await this.getAvailableProposal();
            if (!proposalId)
                break;
            this.logger?.debug(`Creating agreement using proposal ID: ${proposalId}`);
            try {
                agreement = await Agreement.create(proposalId, this.config.options);
                agreement = await this.waitForAgreementApproval(agreement);
                const state = await agreement.getState();
                this.lastAgreementRejectedByProvider.set(agreement.provider.id, state === AgreementStateEnum.Rejected);
                if (state !== AgreementStateEnum.Approved) {
                    throw new Error(`Agreement ${agreement.id} cannot be approved. Current state: ${state}`);
                }
            }
            catch (e) {
                this.logger?.error(`Unable to create agreement form available proposal: ${e?.data?.message || e}`);
                await sleep(2);
                agreement = null;
            }
        }
        if (agreement) {
            this.agreements.set(agreement.id, agreement);
            this.logger?.info(`Agreement confirmed by provider ${agreement.provider.name}`);
        }
        else {
            this.isServiceRunning && this.logger?.debug(`Agreement cannot be created due to no available offers from market`);
        }
        return agreement;
    }
    async getAvailableProposal() {
        let proposal;
        let timeout = false;
        const timeoutId = setTimeout(() => (timeout = true), this.config.agreementWaitingForProposalTimout);
        while (!proposal && this.isServiceRunning && !timeout) {
            proposal = this.proposals.pop();
            if (!proposal) {
                if (+new Date() > this.initialTime + 9000)
                    this.logger?.warn(`No offers have been collected from the market`);
                await sleep(10);
            }
        }
        clearTimeout(timeoutId);
        this.initialTime = +new Date();
        return proposal;
    }
    async waitForAgreementApproval(agreement) {
        const state = await agreement.getState();
        if (state === AgreementStateEnum.Proposal) {
            await agreement.confirm();
            this.logger?.debug(`Agreement proposed to provider '${agreement.provider.name}'`);
        }
        await this.config.api.waitForApproval(agreement.id, this.config.agreementWaitingForApprovalTimeout);
        return agreement;
    }
}
//# sourceMappingURL=service.js.map