import { Deploy, DownloadFile, Run, Script, Start, UploadFile } from "../script/index.js";
import { ActivityStateEnum } from "../activity/index.js";
import { sleep, runtimeContextChecker } from "../utils/index.js";
import { Batch } from "./index.js";
const DEFAULTS = {
    workTimeout: 10000,
    activityStateCheckInterval: 1000,
};
export class WorkContext {
    activity;
    options;
    provider;
    workTimeout;
    logger;
    activityStateCheckingInterval;
    storageProvider;
    networkNode;
    constructor(activity, options) {
        this.activity = activity;
        this.options = options;
        this.workTimeout = options?.workTimeout || DEFAULTS.workTimeout;
        this.logger = options?.logger;
        this.activityStateCheckingInterval = options?.activityStateCheckingInterval || DEFAULTS.activityStateCheckInterval;
        this.provider = options?.provider;
        this.storageProvider = options?.storageProvider;
        this.networkNode = options?.networkNode;
    }
    async before() {
        let state = await this.activity.getState();
        if (state === ActivityStateEnum.Ready) {
            if (this.options?.initWorker)
                await this.options?.initWorker(this, undefined);
            return;
        }
        if (state === ActivityStateEnum.Initialized) {
            await this.activity.execute(new Script([new Deploy(this.networkNode?.getNetworkConfig?.()), new Start()]).getExeScriptRequest());
        }
        let timeout = false;
        const timeoutId = setTimeout(() => (timeout = true), this.workTimeout);
        while (state !== ActivityStateEnum.Ready && !timeout && this.options?.isRunning()) {
            await sleep(this.activityStateCheckingInterval, true);
            state = await this.activity.getState();
        }
        clearTimeout(timeoutId);
        if (state !== ActivityStateEnum.Ready) {
            throw new Error(`Activity ${this.activity.id} cannot reach the Ready state. Current state: ${state}`);
        }
        if (this.options?.initWorker)
            await this.options?.initWorker(this, undefined);
    }
    async run(...args) {
        const command = args.length === 1 ? new Run("/bin/sh", ["-c", args[0]]) : new Run(args[0], args[1]);
        return this.runOneCommand(command);
    }
    async uploadFile(src, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Upload File");
        return this.runOneCommand(new UploadFile(this.storageProvider, src, dst));
    }
    async uploadJson(json, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Upload JSON");
        const src = Buffer.from(JSON.stringify(json), "utf-8");
        return this.runOneCommand(new UploadFile(this.storageProvider, src, dst));
    }
    async downloadFile(src, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Download File");
        return this.runOneCommand(new DownloadFile(this.storageProvider, src, dst));
    }
    beginBatch() {
        return Batch.create(this.activity, this.storageProvider, this.logger);
    }
    rejectResult(msg) {
        throw new Error(`Work rejected by user. Reason: ${msg}`);
    }
    getWebsocketUri(port) {
        if (!this.networkNode)
            throw new Error("There is no network in this work context");
        return this.networkNode?.getWebsocketUri(port);
    }
    async runOneCommand(command) {
        const script = new Script([command]);
        await script.before();
        await sleep(100, true);
        const results = await this.activity.execute(script.getExeScriptRequest());
        const allResults = [];
        for await (const result of results)
            allResults.push(result);
        const commandsErrors = allResults.filter((res) => res.result === "Error");
        await script.after();
        if (commandsErrors.length) {
            const errorMessage = commandsErrors
                .map((err) => `Error: ${err.message}. Stdout: ${err.stdout?.trim()}. Stderr: ${err.stderr?.trim()}`)
                .join(". ");
            this.rejectResult(`Task error on provider ${this.provider?.name || "'unknown'"}. ${errorMessage}`);
            throw new Error(errorMessage);
        }
        return allResults[0];
    }
}
//# sourceMappingURL=work.js.map