import { DownloadFile, Run, Script, UploadFile } from "../script/index.js";
import { runtimeContextChecker, sleep } from "../utils/index.js";
import { Transform } from "stream";
export class Batch {
    activity;
    storageProvider;
    logger;
    script;
    static create(activity, storageProvider, logger) {
        return new Batch(activity, storageProvider, logger);
    }
    constructor(activity, storageProvider, logger) {
        this.activity = activity;
        this.storageProvider = storageProvider;
        this.logger = logger;
        this.script = new Script([]);
    }
    run(...args) {
        this.script.add(args.length === 1 ? new Run("/bin/sh", ["-c", args[0]]) : new Run(args[0], args[1]));
        return this;
    }
    uploadFile(src, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Upload File");
        this.script.add(new UploadFile(this.storageProvider, src, dst));
        return this;
    }
    uploadJson(json, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Upload JSON");
        const src = Buffer.from(JSON.stringify(json), "utf-8");
        this.script.add(new UploadFile(this.storageProvider, src, dst));
        return this;
    }
    downloadFile(src, dst) {
        runtimeContextChecker.checkAndThrowUnsupportedInBrowserError("Download File");
        this.script.add(new DownloadFile(this.storageProvider, src, dst));
        return this;
    }
    async end() {
        await this.script.before();
        await sleep(100, true);
        const results = await this.activity.execute(this.script.getExeScriptRequest());
        const allResults = [];
        return new Promise((res, rej) => {
            results.on("data", (res) => {
                allResults.push(res);
                if (res.result === "Error") {
                    this.script.after();
                    return rej(`Error: ${res.message}`);
                }
            });
            results.on("end", () => {
                this.script.after();
                res(allResults);
            });
            results.on("error", (error) => {
                this.script.after();
                rej(error);
            });
        });
    }
    async endStream() {
        const script = this.script;
        await script.before();
        const results = await this.activity.execute(this.script.getExeScriptRequest());
        const errorResultHandler = new Transform({
            objectMode: true,
            transform(chunk, encoding, callback) {
                const error = chunk?.result === "Error"
                    ? new Error(`${chunk?.message}. Stdout: ${chunk?.stdout?.trim()}. Stderr: ${chunk?.stderr?.trim()}`)
                    : null;
                if (error) {
                    script.after();
                    this.destroy(error);
                }
                else
                    callback(null, chunk);
            },
        });
        results.on("end", () => this.script.after());
        results.on("error", (error) => {
            script.after();
            results.destroy(error);
        });
        return results.pipe(errorResultHandler);
    }
}
//# sourceMappingURL=batch.js.map