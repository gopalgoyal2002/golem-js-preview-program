export var ComparisonOperator;
(function (ComparisonOperator) {
    ComparisonOperator["Eq"] = "=";
    ComparisonOperator["Lt"] = "<";
    ComparisonOperator["Gt"] = ">";
    ComparisonOperator["GtEq"] = ">=";
    ComparisonOperator["LtEq"] = "<=";
})(ComparisonOperator || (ComparisonOperator = {}));
export class DecorationsBuilder {
    properties = [];
    constraints = [];
    addProperty(key, value) {
        const findIndex = this.properties.findIndex((prop) => prop.key === key);
        if (findIndex >= 0) {
            this.properties[findIndex] = { key, value };
        }
        else {
            this.properties.push({ key, value });
        }
        return this;
    }
    addConstraint(key, value, comparisonOperator = ComparisonOperator.Eq) {
        this.constraints.push({ key, value, comparisonOperator });
        return this;
    }
    getDecorations() {
        return {
            properties: this.properties,
            constraints: this.constraints.map((c) => `(${c.key + c.comparisonOperator + c.value})`),
        };
    }
    getDemandRequest() {
        const decorations = this.getDecorations();
        let constraints;
        if (!decorations.constraints.length)
            constraints = "(&)";
        else if (decorations.constraints.length == 1)
            constraints = decorations.constraints[0];
        else
            constraints = `(&${decorations.constraints.join("\n\t")})`;
        const properties = {};
        decorations.properties.forEach((prop) => (properties[prop.key] = prop.value));
        return { constraints, properties };
    }
    parseConstraint(constraint) {
        for (const key in ComparisonOperator) {
            const value = ComparisonOperator[key];
            const parsedConstraint = constraint.slice(1, -1).split(value);
            if (parsedConstraint.length === 2) {
                return {
                    key: parsedConstraint[0],
                    value: parsedConstraint[1],
                    comparisonOperator: ComparisonOperator[key],
                };
            }
        }
        throw new Error(`Unable to parse constraint "${constraint}"`);
    }
    addDecoration(decoration) {
        if (decoration.properties) {
            decoration.properties.forEach((prop) => {
                this.addProperty(prop.key, prop.value);
            });
        }
        if (decoration.constraints) {
            decoration.constraints.forEach((cons) => {
                const { key, value, comparisonOperator } = { ...this.parseConstraint(cons) };
                this.addConstraint(key, value, comparisonOperator);
            });
        }
        return this;
    }
    addDecorations(decorations) {
        decorations.forEach((d) => this.addDecoration(d));
        return this;
    }
}
//# sourceMappingURL=builder.js.map