import { Package } from "../package/index.js";
import { MarketService } from "../market/index.js";
import { AgreementPoolService } from "../agreement/index.js";
import { Task, TaskQueue, TaskService } from "../task/index.js";
import { PaymentService } from "../payment/index.js";
import { NetworkService } from "../network/index.js";
import { sleep, runtimeContextChecker } from "../utils/index.js";
import { GftpStorageProvider } from "../storage/index.js";
import { ExecutorConfig } from "./config.js";
import { Events } from "../events/index.js";
import { StatsService } from "../stats/service.js";
export class TaskExecutor {
    options;
    marketService;
    agreementPoolService;
    taskService;
    paymentService;
    networkService;
    statsService;
    initWorker;
    taskQueue;
    storageProvider;
    logger;
    lastTaskIndex = 0;
    isRunning = true;
    static async create(options) {
        const executor = new TaskExecutor(options);
        await executor.init();
        return executor;
    }
    constructor(options) {
        const configOptions = (typeof options === "string" ? { package: options } : options);
        this.options = new ExecutorConfig(configOptions);
        this.logger = this.options.logger;
        this.taskQueue = new TaskQueue();
        this.agreementPoolService = new AgreementPoolService(this.options);
        this.paymentService = new PaymentService(this.options);
        this.marketService = new MarketService(this.agreementPoolService, this.options);
        this.networkService = this.options.networkIp ? new NetworkService(this.options) : undefined;
        this.storageProvider = runtimeContextChecker.isNode ? new GftpStorageProvider(this.logger) : undefined;
        this.taskService = new TaskService(this.taskQueue, this.agreementPoolService, this.paymentService, this.networkService, { ...this.options, storageProvider: this.storageProvider });
        this.statsService = new StatsService(this.options);
    }
    async init() {
        const taskPackage = typeof this.options.package === "string" ? await this.createPackage(this.options.package) : this.options.package;
        this.logger?.debug("Initializing task executor services...");
        const allocations = await this.paymentService.createAllocations();
        this.marketService.run(taskPackage, allocations).catch((e) => this.handleCriticalError(e));
        this.agreementPoolService.run().catch((e) => this.handleCriticalError(e));
        this.paymentService.run().catch((e) => this.handleCriticalError(e));
        this.taskService.run().catch((e) => this.handleCriticalError(e));
        this.networkService?.run().catch((e) => this.handleCriticalError(e));
        this.statsService.run().catch((e) => this.handleCriticalError(e));
        this.storageProvider?.init().catch((e) => this.handleCriticalError(e));
        if (runtimeContextChecker.isNode)
            this.handleCancelEvent();
        this.options.eventTarget.dispatchEvent(new Events.ComputationStarted());
        this.logger?.info(`Task Executor has started using subnet: ${this.options.subnetTag}, network: ${this.options.payment?.network}, driver: ${this.options.payment?.driver}`);
    }
    async end() {
        if (!this.isRunning)
            return;
        this.isRunning = false;
        await this.networkService?.end();
        await this.taskService.end();
        await this.agreementPoolService.end();
        await this.marketService.end();
        await this.paymentService.end();
        this.storageProvider?.close();
        this.options.eventTarget?.dispatchEvent(new Events.ComputationFinished());
        this.printStats();
        await this.statsService.end();
        this.logger?.info("Task Executor has shut down");
    }
    getStats() {
        return this.statsService.getStatsTree();
    }
    beforeEach(worker) {
        this.initWorker = worker;
    }
    async run(worker) {
        return this.executeTask(worker).catch(async (e) => {
            await this.handleCriticalError(e);
            return undefined;
        });
    }
    map(data, worker) {
        const inputs = [...data];
        const featureResults = inputs.map((value) => this.executeTask(worker, value));
        const results = [];
        let resultsCount = 0;
        featureResults.forEach((featureResult) => featureResult
            .then((res) => {
            results.push(res);
        })
            .catch((e) => this.handleCriticalError(e)));
        const isRunning = () => this.isRunning;
        return {
            [Symbol.asyncIterator]() {
                return {
                    async next() {
                        if (resultsCount === inputs.length) {
                            return Promise.resolve({ done: true, value: undefined });
                        }
                        while (results.length === 0 && resultsCount < inputs.length && isRunning()) {
                            await sleep(1000, true);
                        }
                        if (!isRunning())
                            return Promise.resolve({ done: true, value: undefined });
                        resultsCount += 1;
                        return Promise.resolve({ done: false, value: results.pop() });
                    },
                };
            },
        };
    }
    async forEach(data, worker) {
        await Promise.all([...data].map((value) => this.executeTask(worker, value))).catch((e) => this.handleCriticalError(e));
    }
    async createPackage(imageHash) {
        return Package.create({ ...this.options.packageOptions, imageHash });
    }
    async executeTask(worker, data) {
        const task = new Task((++this.lastTaskIndex).toString(), worker, data, this.initWorker);
        this.taskQueue.addToEnd(task);
        let timeout = false;
        const timeoutId = setTimeout(() => (timeout = true), this.options.taskTimeout);
        while (!timeout && this.isRunning) {
            if (task.isFinished()) {
                clearTimeout(timeoutId);
                if (task.isRejected())
                    throw task.getError();
                return task.getResults();
            }
            await sleep(2000, true);
        }
        clearTimeout(timeoutId);
        if (timeout) {
            const error = new Error(`Task ${task.id} timeout.`);
            task.stop(undefined, error);
            throw error;
        }
    }
    handleCriticalError(e) {
        this.options.eventTarget?.dispatchEvent(new Events.ComputationFailed({ reason: e.toString() }));
        this.logger?.error(e.toString());
        this.logger?.debug(e.stack);
        if (this.isRunning)
            this.logger?.warn("Trying to stop executor...");
        this.end().catch((e) => {
            this.logger?.error(e);
            process?.exit(1);
        });
    }
    handleCancelEvent() {
        const terminatingSignals = ["SIGINT", "SIGTERM", "SIGBREAK", "SIGHUP"];
        const cancel = async () => {
            terminatingSignals.forEach((event) => process.off(event, cancel));
            this.logger?.warn("Executor has interrupted by the user. Stopping all tasks...");
            await this.end().catch((error) => {
                this.logger?.error(error);
                process.exit(1);
            });
        };
        terminatingSignals.forEach((event) => process.on(event, cancel));
    }
    printStats() {
        const costs = this.statsService.getAllCosts();
        const costsSummary = this.statsService.getAllCostsSummary();
        const duration = this.statsService.getComputationTime();
        const providersCount = new Set(costsSummary.map((x) => x["Provider Name"])).size;
        this.logger?.info(`Computation finished in ${duration}`);
        this.logger?.info(`Negotiated ${costsSummary.length} agreements with ${providersCount} providers`);
        if (costsSummary.length)
            this.logger?.table?.(costsSummary);
        this.logger?.info(`Total Cost: ${costs.total} Total Paid: ${costs.paid}`);
    }
}
//# sourceMappingURL=executor.js.map