import { Package, PackageOptions } from "../package/index.js";
import { DemandOptions } from "../market/index.js";
import { AgreementOptions } from "../agreement/index.js";
import { Worker } from "../task/index.js";
import { ActivityOptions, Result } from "../activity/index.js";
import { Logger } from "../utils/index.js";
import { TaskOptions } from "../task/service.js";
import { BasePaymentOptions } from "../payment/config.js";
import { NetworkServiceOptions } from "../network/service.js";
import { AgreementServiceOptions } from "../agreement/service.js";
import { WorkOptions } from "../task/work.js";
import { LogLevel } from "../utils/logger.js";
export type ExecutorOptions = {
    package: string | Package;
    taskTimeout?: number;
    subnetTag?: string;
    logger?: Logger;
    logLevel?: LogLevel | string;
    yagnaOptions?: YagnaOptions;
    eventTarget?: EventTarget;
} & ActivityOptions & AgreementOptions & BasePaymentOptions & DemandOptions & Omit<PackageOptions, "imageHash"> & TaskOptions & NetworkServiceOptions & AgreementServiceOptions & Omit<WorkOptions, "isRunning">;
export type ExecutorOptionsMixin = string | ExecutorOptions;
export type YagnaOptions = {
    apiKey: string;
    basePath: string;
};
export declare class TaskExecutor {
    private readonly options;
    private marketService;
    private agreementPoolService;
    private taskService;
    private paymentService;
    private networkService?;
    private statsService;
    private initWorker?;
    private taskQueue;
    private storageProvider?;
    private logger?;
    private lastTaskIndex;
    private isRunning;
    static create(options: ExecutorOptionsMixin): Promise<TaskExecutor>;
    private constructor();
    init(): Promise<void>;
    end(): Promise<void>;
    getStats(): {
        allocations: any;
        providers: any;
    };
    beforeEach(worker: Worker): void;
    run<OutputType = Result>(worker: Worker<undefined, OutputType>): Promise<OutputType | undefined>;
    map<InputType, OutputType>(data: Iterable<InputType>, worker: Worker<InputType, OutputType>): AsyncIterable<OutputType | undefined>;
    forEach<InputType, OutputType>(data: Iterable<InputType>, worker: Worker<InputType, OutputType>): Promise<void>;
    private createPackage;
    private executeTask;
    private handleCriticalError;
    private handleCancelEvent;
    private printStats;
}
