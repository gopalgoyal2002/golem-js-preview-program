import { AllocationConfig } from "./config.js";
import { Events } from "../events/index.js";
export class Allocation {
    options;
    id;
    timestamp;
    timeout;
    address;
    paymentPlatform;
    totalAmount;
    spentAmount;
    remainingAmount;
    static async create(options) {
        const config = new AllocationConfig(options);
        const now = new Date();
        const model = {
            totalAmount: config.budget.toString(),
            paymentPlatform: config.account.platform,
            address: config.account.address,
            timestamp: now.toISOString(),
            timeout: new Date(+now + config.expires).toISOString(),
            makeDeposit: false,
            remainingAmount: "",
            spentAmount: "",
            allocationId: "",
        };
        const { data: newModel } = await config.api.createAllocation(model).catch((error) => {
            throw new Error(`Could not create new allocation. ${error.response?.data?.message || error.response?.data || error}`);
        });
        config.eventTarget?.dispatchEvent(new Events.AllocationCreated({
            id: newModel.allocationId,
            amount: parseFloat(newModel.totalAmount),
            platform: newModel.paymentPlatform,
        }));
        config.logger?.debug(`Allocation ${newModel.allocationId} has been created using payment platform ${config.account.platform}`);
        return new Allocation(config, newModel);
    }
    constructor(options, model) {
        this.options = options;
        this.id = model.allocationId;
        this.timeout = model.timeout;
        this.timestamp = model.timestamp;
        this.totalAmount = model.totalAmount;
        this.spentAmount = model.spentAmount;
        this.remainingAmount = model.remainingAmount;
        if (!model.address || !model.paymentPlatform)
            throw new Error("Account address and payment platform are required");
        this.address = model.address;
        this.paymentPlatform = model.paymentPlatform;
    }
    async getRemainingAmount() {
        await this.refresh();
        return this.remainingAmount;
    }
    async getSpentAmount() {
        await this.refresh();
        return this.spentAmount;
    }
    async release() {
        await this.options.api.releaseAllocation(this.id).catch((e) => {
            throw new Error(`Could not release allocation. ${e.response?.data?.message || e}`);
        });
        this.options?.logger?.debug(`Allocation ${this.id} has been released.`);
    }
    async getDemandDecoration() {
        const { data: decoration } = await this.options.api.getDemandDecorations([this.id]).catch((e) => {
            throw new Error(`Unable to get demand decorations. ${e.response?.data?.message || e}`);
        });
        return decoration;
    }
    async refresh() {
        const { data } = await this.options.api.getAllocation(this.id).catch((e) => {
            throw new Error(`Could not get allocation data. ${e.response?.data || e}`);
        });
        this.remainingAmount = data.remainingAmount;
        this.spentAmount = data.spentAmount;
    }
}
//# sourceMappingURL=allocation.js.map